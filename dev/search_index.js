var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PlantGraphs","category":"page"},{"location":"#Graphs","page":"Home","title":"Graphs","text":"","category":"section"},{"location":"#Types","page":"Home","title":"Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Graph","category":"page"},{"location":"#PlantGraphs.Graph","page":"Home","title":"PlantGraphs.Graph","text":"Graph(;axiom, rules = nothing, data = nothing)\n\nCreate a dynamic graph from an axiom, one or more rules and, optionally, graph-level variables.\n\nArguments\n\naxiom: A single object inheriting from Node or a subgraph generated  with\n\nthe graph construction DSL. It should represent the initial state of the dynamic graph.\n\nKeywords\n\nrules:  A single Rule object or a tuple of Rule objects (optional). It\n\nshould include all graph-rewriting rules of the graph.\n\ndata: A single object of any user-defined type (optional). This will be the\n\ngraph-level variable accessible from any rule or query applied to the graph.\n\nFT: Floating-point precision to be used when generating the 3D geometry\n\nassociated to a graph.\n\nDetails\n\nAll arguments are assigned by keyword. The axiom and rules are deep-copied when creating the graph but the graph-level variables (if a copy is needed due to mutability, the user needs to care of that).\n\nReturns\n\nAn object of type Graph representing a dynamic graph. Printing this object results in a human-readable description of the type of data stored in the graph.\n\nExamples\n\njulia> let\n           struct A0 <: Node end\n           struct B0 <: Node end\n           axiom = A0() + B0()\n           no_rules_graph = Graph(axiom = axiom)\n           rule = Rule(A0, rhs = x -> A0() + B0())\n           rules_graph = Graph(axiom = axiom, rules = rule)\n       end\nDynamic graph with 2 nodes of types A0,B0 and 1 rewriting rules.\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Rule","category":"page"},{"location":"#PlantGraphs.Rule","page":"Home","title":"PlantGraphs.Rule","text":"Rule(nodetype; lhs = x -> true, rhs = x -> nothing, captures = false)\n\nCreate a replacement rule for nodes of type nodetype.\n\nArguments\n\nnodetype: Type of node to be matched.\n\nKeywords\n\nlhs: Function or function-like object that takes a Context object and\n\nreturns whether the node should be replaced or not (with true or false).\n\nrhs: Function or function-like object that takes one or more Context\n\nobjects and returns a replacement graph or nothing. If it takes several inputs, the first one will correspond to the node being replaced.\n\ncaptures: Either false or true to indicate whether the left-hand side\n\nof the rule is capturing nodes in the context of the replacement node to be used for the construction of the replace graph.\n\nDetails\n\nSee VPL documentation for details on rule-based graph rewriting.\n\nReturn\n\nAn object of type Rule.\n\nExamples\n\njulia> let\n           struct A <: Node end\n           struct B <: Node end\n           axiom = A() + B()\n           rule = Rule(A, rhs = x -> A() + B())\n           rules_graph = Graph(axiom = axiom, rules = rule)\n           rewrite!(rules_graph)\n           end\n\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Query","category":"page"},{"location":"#PlantGraphs.Query","page":"Home","title":"PlantGraphs.Query","text":"Query(N::DataType; condition = x -> true)\n\nCreate a query that matches nodes of type nodetype and a condition.\n\nArguments\n\nN::DataType: Type of node to be matched.\n\nKeywords\n\ncondition: Function or function-like object that checks if a node should be\n\nselected.\n\nDetails\n\nIf the nodetype should refer to a concrete type and match one of the types stored inside the graph. Abstract types or types that are not contained in the graph are allowed but the query will never return anything.\n\nThe condition must be a function or function-like object that takes a Context as input and returns true or false. The default condition always return true such that the query will\n\nReturns\n\nIt returns an object of type Query. Use apply() to execute the query on a dynamic graph.\n\nExamples\n\njulia> struct A <: Node end\n\n\njulia> struct B <: Node end\n\n\njulia> axiom = A() + B();\n\njulia> g = Graph(axiom = axiom)\nDynamic graph with 2 nodes of types A,B and 0 rewriting rules.\n\njulia> query = Query(A)\nQuery object for nodes of type A\n\njulia> apply(g, query)\n1-element Vector{A}:\n A()\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Node","category":"page"},{"location":"#PlantGraphs.Node","page":"Home","title":"PlantGraphs.Node","text":"Node\n\nAbstract type from which every node in a graph should inherit. This allows using the graph construction DSL.\n\nExample\n\njulia> let\n         struct bar <: Node\n           x::Int\n         end\n         b1 = bar(1)\n         b2 = bar(2)\n         b1 + b2\n       end;\n\n\n\n\n\n","category":"type"},{"location":"","page":"Home","title":"Home","text":"Context","category":"page"},{"location":"#PlantGraphs.Context","page":"Home","title":"PlantGraphs.Context","text":"Context\n\nData structure than links a node to the rest of the graph.\n\nFields\n\ngraph: Dynamic graph that contains the node.\nnode: Node inside the graph.\n\nDetails\n\nA Context object wraps references to a node and its associated graph. The purpose of this structure is to be able to test relationships among nodes within a graph (from with a query or rule), as well as access the data stored in a node (with data()) or the graph (with graph_data()).\n\nUsers do not build Context objects directly but they are provided by VPL as inputs to the user-defined functions inside rules and queries.\n\n\n\n\n\n","category":"type"},{"location":"#Graph-DSL","page":"Home","title":"Graph DSL","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"+(n1::Node, n2::Node)\n+(g::StaticGraph, n::Node)\n+(n::Node, g::StaticGraph)\n+(g1::StaticGraph, g2::StaticGraph)\n+(n::Node, T::Tuple)","category":"page"},{"location":"#Base.:+-Tuple{Node, Node}","page":"Home","title":"Base.:+","text":"+(n1::Node, n2::Node)\n\nCreates a graph with two nodes where n1 is the root and n2 is the insertion point.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + B1(1)\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{PlantGraphs.StaticGraph, Node}","page":"Home","title":"Base.:+","text":"+(g::StaticGraph, n::Node)\n\nCreates a graph as the result of appending the node n to the insertion point of graph g.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + B1(1)\n           axiom = axiom + A1(2)\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{Node, PlantGraphs.StaticGraph}","page":"Home","title":"Base.:+","text":"+(n::Node, g::StaticGraph)\n\nCreates a graph as the result of appending the static graph g to the node n.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + B1(1)\n           axiom = A1(2) + axiom\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.StaticGraph}","page":"Home","title":"Base.:+","text":"+(g1::StaticGraph, g2::StaticGraph)\n\nCreates a graph as the result of appending g2 to the insertion point of g1. The insertion point of the final graph corresponds to the insertion point of g2.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom1 = A1(1) + B1(1)\n           axiom2 = A1(2) + B1(2)\n           axiom = axiom1 + axiom2\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{Node, Tuple}","page":"Home","title":"Base.:+","text":"+(g::StaticGraph, T::Tuple)\n+(n::Node, T::Tuple)\n\nCreates a graph as the result of appending a tuple of graphs/nodes T to the insertion point of the graph g or node n. Each graph/node in L becomes a branch.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + (B1(1) + A1(3), B1(4))\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(axiom)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"#Applying-rules-and-queries","page":"Home","title":"Applying rules and queries","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"apply(g::Graph, query::Query)","category":"page"},{"location":"#PlantGraphs.apply-Tuple{Graph, Query}","page":"Home","title":"PlantGraphs.apply","text":"apply(g::Graph, query::Query)\n\nReturn an array with all the nodes in the graph that match the query supplied by the user.\n\nExamples\n\njulia> struct A <: Node end\n\n\njulia> struct B <: Node end\n\n\njulia> axiom = A() + B();\n\njulia> g = Graph(axiom = axiom)\nDynamic graph with 2 nodes of types A,B and 0 rewriting rules.\n\njulia> query = Query(A)\nQuery object for nodes of type A\n\njulia> apply(g, query)\n1-element Vector{A}:\n A()\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"rewrite!(g::Graph)","category":"page"},{"location":"#PlantGraphs.rewrite!-Tuple{Graph}","page":"Home","title":"PlantGraphs.rewrite!","text":"rewrite!(g::Graph)\n\nApply the graph-rewriting rules stored in the graph.\n\nArguments\n\ng::Graph: The graph to be rewritten. It will be modified in-place.\n\nDetails\n\nThis function will match the left-hand sides of all the rules in a graph. If any node is matched by more than one rule this will result in an error. The rules are then applied in order to replaced the matched nodes with the result of executing the right hand side of the rules. The rules are applied in the order in which they are stored in the graph but the order in which the nodes are processed is not defined. Since graph rewriting is semantically a parallel process, the rules should not be rely on any particular order for their functioning.\n\nReturns\n\nThis function returns nothing, but the graph passed as input will be modified by the execution of the rules.\n\nExamples\n\njulia> let\n           struct A <: Node end\n           struct B <: Node end\n           axiom = A() + B()\n           rule = Rule(A, rhs = x -> A() + B())\n           g = Graph(axiom = axiom, rules = rule)\n           rewrite!(g)\n       end\n\n\n\n\n\n\n","category":"method"},{"location":"#Extracting-information","page":"Home","title":"Extracting information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"data(g::Graph)","category":"page"},{"location":"#PlantGraphs.data-Tuple{Graph}","page":"Home","title":"PlantGraphs.data","text":"data(g::Graph)\n\nReturns the graph-level variables.\n\nExample\n\njulia> struct A <: Node end\n\n\njulia> axiom = A()\nA()\n\njulia> g = Graph(axiom = axiom, data = 2)\nDynamic graph with 1 nodes of types A and 0 rewriting rules.\nDynamic graph variables stored in struct of type Int64\n\njulia> data(g)\n2\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"rules(g::Graph)","category":"page"},{"location":"#PlantGraphs.rules-Tuple{Graph}","page":"Home","title":"PlantGraphs.rules","text":"rules(g::Graph)\n\nReturns a tuple with all the graph-rewriting rules stored in a dynamic graph\n\nExamples\n\njulia> struct A <: Node end\n\n\njulia> struct B <: Node end\n\n\njulia> axiom = A() + B();\n\njulia> rule = Rule(A, rhs = x -> A() + B())\nRule replacing nodes of type A without context capturing.\n\njulia> rules_graph = Graph(axiom = axiom, rules = rule)\nDynamic graph with 2 nodes of types A,B and 1 rewriting rules.\n\njulia> rules(rules_graph)\n(Rule replacing nodes of type A without context capturing.\n,)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"data(c::Context)","category":"page"},{"location":"#PlantGraphs.data-Tuple{PlantGraphs.Context}","page":"Home","title":"PlantGraphs.data","text":"data(c::Context)\n\nReturns the data stored in a node. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"graph_data(c::Context)","category":"page"},{"location":"#PlantGraphs.graph_data-Tuple{PlantGraphs.Context}","page":"Home","title":"PlantGraphs.graph_data","text":"graph_data(c::Context)\n\nReturns the graph-level variables. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"#Node-relations","page":"Home","title":"Node relations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"has_parent(c::Context)","category":"page"},{"location":"#PlantGraphs.has_parent-Tuple{PlantGraphs.Context}","page":"Home","title":"PlantGraphs.has_parent","text":"has_parent(c::Context)\n\nCheck if a node has a parent and return true or false. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"isroot(c::Context)","category":"page"},{"location":"#AbstractTrees.isroot-Tuple{PlantGraphs.Context}","page":"Home","title":"AbstractTrees.isroot","text":"isroot(c::Context)\n\nCheck if a node is the root of the graph (i.e., has no parent) and return true or false. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"has_ancestor(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))","category":"page"},{"location":"#PlantGraphs.has_ancestor-Tuple{PlantGraphs.Context}","page":"Home","title":"PlantGraphs.has_ancestor","text":"has_ancestor(c::Context; condition = x -> true, max_level::Int = typemax(Int))\n\nCheck if a node has an ancestor that matches the condition. Intended to be used within a rule or query.\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false.\n\nmax_level::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\nDetails\n\nThis function traverses the graph from the node associated to c towards the root of the graph until a node is found for which condition returns true. If no node meets the condition, then it will return false. The defaults values for this function are such that the algorithm always returns true after one step (unless it is applied to the root node) in which case it is equivalent to calling has_parent on the node.\n\nThe number of levels that the algorithm is allowed to traverse is capped by max_level (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\n\nThe function condition should take an object of type Context as input and return true or false.\n\nReturns\n\nReturn a tuple with two values a Bool and an Int, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(2) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               has_ancestor(n, condition = x -> data(x).val == 1)[1]\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n               Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(3)], B1[])\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"parent(c::Context; nsteps::Int)","category":"page"},{"location":"#Base.parent-Tuple{PlantGraphs.Context}","page":"Home","title":"Base.parent","text":"parent(c::Context; nsteps::Int)\n\nReturns the parent of a node that is nsteps away towards the root of the graph. Intended to be used within a rule or query.\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\nnsteps: Number of steps to traverse the graph towards the root node.\n\nDetails\n\nIf has_parent() returns false for the same node or the algorithm has reached the root node but nsteps have not been reached, then parent() will return missing, otherwise it returns the Context associated to the matching node.\n\nReturn\n\nReturn a Context object or missing.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(2) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               np = parent(n, nsteps = 2)\n               !ismissing(np) && data(np).val == 2\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n           Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(3)], B1[])\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"ancestor(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))","category":"page"},{"location":"#PlantGraphs.ancestor-Tuple{PlantGraphs.Context}","page":"Home","title":"PlantGraphs.ancestor","text":"ancestor(c::Context; condition = x -> true, max_level::Int = typemax(Int))\n\nReturns the first ancestor of a node that matches the condition. Intended to be used within a rule or query.\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false.\n\nmax_level::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\nDetails\n\nIf has_ancestor() returns false for the same node and condition, ancestor() will return missing, otherwise it returns the Context associated to the matching node\n\nReturns\n\nReturn a Context object or missing.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               na = ancestor(n, condition = x -> (data(x).val == 1))\n               if !ismissing(na)\n                   data(na) isa B1\n               else\n                   false\n               end\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n           Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(3)], B1[])\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"haschildren(c::Context)","category":"page"},{"location":"#PlantGraphs.haschildren-Tuple{PlantGraphs.Context}","page":"Home","title":"PlantGraphs.haschildren","text":"haschildren(c::Context)\n\nCheck if a node has at least one child and return true or false. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"isleaf(c::Context)","category":"page"},{"location":"#PlantGraphs.isleaf-Tuple{PlantGraphs.Context}","page":"Home","title":"PlantGraphs.isleaf","text":"isleaf(c::Context)\n\nCheck if a node is a leaf in the graph (i.e., has no children) and return true or false. Intended to be used within a rule or query.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"hasdescendant(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))","category":"page"},{"location":"#PlantGraphs.hasdescendant-Tuple{PlantGraphs.Context}","page":"Home","title":"PlantGraphs.hasdescendant","text":"hasdescendant(c::Context; condition = x -> true, max_level::Int = typemax(Int))\n\nCheck if a node has a descendant that matches the optional condition. Intended to be used within a rule or query.\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false.\n\nmax_level::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\nDetails\n\nThis function traverses the graph from the node associated to c towards the leaves of the graph until a node is found for which condition returns true. If no node meets the condition, then it will return false. The defaults values for this function are such that the algorithm always returns true after one step (unless it is applied to a leaf node) in which case it is equivalent to calling haschildren on the node.\n\nThe number of levels that the algorithm is allowed to traverse is capped by max_level (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).\n\nThe function condition should take an object of type Context as input and return true or false.\n\nReturns\n\nReturn a tuple with two values a Bool and an Int, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(2) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               hasdescendant(n, condition = x -> data(x).val == 1)[1]\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n           Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(2)], B1[])\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"children(c::Context)","category":"page"},{"location":"#AbstractTrees.children-Tuple{PlantGraphs.Context}","page":"Home","title":"AbstractTrees.children","text":"children(c::Context)\n\nReturns all the children of a node as Context objects.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"getdescendant(c::Context; condition = x -> true, maxlevel::Int = typemax(Int))","category":"page"},{"location":"#AbstractTrees.getdescendant-Tuple{PlantGraphs.Context}","page":"Home","title":"AbstractTrees.getdescendant","text":"getdescendant(c::Context; condition = x -> true, max_level::Int = typemax(Int))\n\nReturns the first descendant of a node that matches the condition. Intended to be used within a rule or query.\n\nArguments\n\nc::Context: Context associated to a node in a dynamic graph.\n\nKeywords\n\ncondition: An user-defined function that takes a Context object as input\n\nand returns true or false.\n\nmax_level::Int: Maximum number of steps that the algorithm may take when\n\ntraversing the graph.\n\nDetails\n\nIf hasdescendant() returns false for the same node and condition, getdescendant() will return missing, otherwise it returns the Context associated to the matching node.\n\nReturn\n\nReturn a Context object or missing.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n               function qfun(n)\n               na = getdescendant(n, condition = x -> (data(x).val == 1))\n               if !ismissing(na)\n                   data(na) isa B1\n               else\n                   false\n               end\n           end\n           Q1 = Query(A1, condition = qfun)\n           R1 = apply(g, Q1)\n           Q2 = Query(B1, condition = qfun)\n           R2 = apply(g, Q2)\n           (R1,R2)\n       end\n(A1[A1(1)], B1[])\n\n\n\n\n\n","category":"method"},{"location":"#Traversal-algorithms","page":"Home","title":"Traversal algorithms","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"traverse(g::Graph; fun = () -> nothing)","category":"page"},{"location":"#PlantGraphs.traverse-Tuple{Graph}","page":"Home","title":"PlantGraphs.traverse","text":"traverse(g::Graph; fun = () -> nothing)\n\nIterates over all the nodes in the graph and execute for the function fun on each node\n\nArguments\n\ng::Graph: The graph object that will be traversed.\n\nKeywords\n\nfun: A function or function-like object defined by the user that will be\n\napplied to each node.\n\nDetails\n\nThis traveral happens in the order in which the nodes are stored in the graph. This order is arbitrary and may vary across executions of the code (it does not correspond to the order in which nodes are created). For algorithms that require a particular traveral order of the graph, see traversedfs and traversebfs.\n\nThis function does not store any results generated by fun. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).\n\nThe function or function-like object provided by the user should take only one argument that corresponds to applying data() to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see Query and general VPL documentation).\n\nReturns\n\nThis function returns nothing but fun may have side-effects.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           struct Foo\n               vals::Vector{Int}\n           end\n           function (f::Foo)(x)\n                   push!(f.vals, x.val)\n           end\n           f = Foo(Int[])\n               axiom = A1(2) + (B1(1) + A1(3), B1(4))\n                   g = Graph(axiom = axiom)\n           traverse(g, fun = f)\n           f.vals\n       end\n4-element Vector{Int64}:\n 2\n 1\n 3\n 4\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"traversedfs(g::Graph; fun = () -> nothing, ID = root_id(g))","category":"page"},{"location":"#PlantGraphs.traversedfs-Tuple{Graph}","page":"Home","title":"PlantGraphs.traversedfs","text":"traversedfs(g::Graph; fun = () -> nothing, ID = root_id(g))\n\nIterates over all the nodes in the graph (depth-first order, starting at a any node) and execute for the function fun on each node\n\nArguments\n\ng::Graph: The graph object that will be traversed.\n\nKeywords\n\nfun: A function or function-like object defined by the user that will be\n\napplied to each node.\n\nID: The ID of the node where the traveral should start. This argument is\n\nassigned by keyword and is, by default, the root of the graph.\n\nDetails\n\nThis traveral happens in a depth-first order. That is, all nodes in a branch of the graph are visited until reach a leaf node, then moving to the next branch. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us breadth-first order see traversebfs.\n\nThis function does not store any results generated by fun. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).\n\nThe function or function-like object provided by the user should take only one argument that corresponds to applying data() to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see Query and general VPL documentation).\n\nReturns\n\nThis function returns nothing but fun may have side-effects.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           struct Foo\n               vals::Vector{Int}\n           end\n           function (f::Foo)(x)\n                   push!(f.vals, x.val)\n           end\n           f = Foo(Int[])\n           axiom = A1(2) + (B1(1) + A1(3), B1(4))\n               g = Graph(axiom = axiom)\n           traversedfs(g, fun = f)\n           f.vals\n       end\n4-element Vector{Int64}:\n 2\n 4\n 1\n 3\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"traversebfs(g::Graph; fun = () -> nothing, ID = root_id(g))","category":"page"},{"location":"#PlantGraphs.traversebfs-Tuple{Graph}","page":"Home","title":"PlantGraphs.traversebfs","text":"traversebfs(g::Graph; fun = () -> nothing, ID = root_id(g))\n\nIterates over all the nodes in the graph (breadth-first order, starting at a any node) and execute for the function fun on each node\n\nArguments\n\ng::Graph: The graph object that will be traversed.\n\nKeywords\n\nfun: A function or function-like object defined by the user that will be\n\napplied to each node.\n\nID: The ID of the node where the traveral should start. This argument is, by default,\n\nthe root of the graph.\n\nDetails\n\nThis traveral happens in a breadth-first order. That is, all nodes at a given depth of the the graph are visited first, then moving on to the next level. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us depth-first order see traversedfs.\n\nThis function does not store any results generated by fun. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).\n\nThe function or function-like object provided by the user should take only one argument that corresponds to applying data() to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see Query and general VPL documentation).\n\nReturns\n\nThis function returns nothing but fun may have side-effects.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           struct Foo\n               vals::Vector{Int}\n           end\n           function (f::Foo)(x)\n               push!(f.vals, x.val)\n           end\n           f = Foo(Int[])\n               axiom = A1(2) + (B1(1) + A1(3), B1(4))\n                   g = Graph(axiom = axiom)\n           traversebfs(g, fun = f)\n           f.vals\n       end\n4-element Vector{Int64}:\n 2\n 1\n 4\n 3\n\n\n\n\n\n","category":"method"},{"location":"#Graph-visualization","page":"Home","title":"Graph visualization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"draw(g::Graph; force = false, inline = false, resolution = (1920, 1080),\n    nlabels_textsize = 15, arrow_size = 15, node_size = 5)\ndraw(g::StaticGraph; force = false, inline = false, resolution = (1920, 1080),\n              nlabels_textsize = 15, arrow_size = 15, node_size = 5)\nnode_label(n::Node, id)","category":"page"},{"location":"#PlantGraphs.draw-Tuple{Graph}","page":"Home","title":"PlantGraphs.draw","text":"draw(g::Graph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,\n     node_size = 5)\n\nVisualize a graph as network diagram.\n\nArguments\n\ng::Graph: The graph to be visualized.\n\nKeywords\n\nresolution = (1920, 1080): The resolution of the image to be rendered, in\n\npixels (online relevant for native and web backends). Default resolution is HD.\n\nnlabels_textsize = 15: Customize the size of the labels in the diagram.\narrow_size = 15: Customize the size of the arrows representing edges in the\n\ndiagram.\n\nnode_size = 5: Customize the size of the nodes in the diagram.\n\nDetails\n\nBy default, nodes are labelled with the type of data stored and their unique ID. See function node_label() to customize the label for different types of data.\n\nSee save from FileIO to export the network diagram as a raster or vector image (depending on the backend). The function calculate_resolution() can be useful to ensure a particular dpi of the exported image (assuming some physical size).\n\nThe graphics backend will interact with the environment where the Julia code is being executed (i.e., terminal, IDE such as VS Code, interactive notebook such as Jupyter or Pluto). These interactions are all controlled by the graphics package Makie that VPL relies on. Some details on the expected behavior specific to draw() can be found in the general VPL documentation.\n\nReturns\n\nThis function returns a Makie Figure object, while producing the visualization as a side effect.\n\nExamples\n\njulia> let\n           struct A1 <: Node val::Int end\n           struct B1 <: Node val::Int end\n           axiom = A1(1) + (B1(1) + A1(3), B1(4))\n           g = Graph(axiom = axiom)\n           import CairoMakie # or GLMakie, WGLMakie, etc.\n           draw(g)\n       end\nFigure()\n\n\n\n\n\n","category":"method"},{"location":"#PlantGraphs.draw-Tuple{PlantGraphs.StaticGraph}","page":"Home","title":"PlantGraphs.draw","text":"draw(g::StaticGraph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,\n     node_size = 5)\n\nEquivalent to the method draw(g::Graph; kwargs...) but  to visualize static graphs (e.g., the axiom of a graph).\n\n\n\n\n\n","category":"method"},{"location":"#PlantGraphs.node_label-Tuple{Node, Any}","page":"Home","title":"PlantGraphs.node_label","text":"node_label(n::Node, id)\n\nFunction to construct a label for a node to be used by draw() when visualizing. The user can specialize this method for user-defined data types to customize the labels. By default, the type of data stored in the node and the unique ID of the node are used as labels.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"calculate_resolution(;width = 1024/300*2.54, height = 768/300*2.54,\n                              format = \"png\", dpi = 300)","category":"page"},{"location":"#PlantGraphs.calculate_resolution-Tuple{}","page":"Home","title":"PlantGraphs.calculate_resolution","text":"calculate_resolution(;width = 1024/300*2.54, height = 768/300*2.54,\n                      format = \"raster\", dpi = 300)\n\nCalculate the resolution required to achieve a specific width and height (in cm) of the exported image, with a particular dpi (for raster formats).\n\n\n\n\n\n","category":"method"}]
}
