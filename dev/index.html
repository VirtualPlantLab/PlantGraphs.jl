<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · PlantGraphs.jl</title><meta name="title" content="Home · PlantGraphs.jl"/><meta property="og:title" content="Home · PlantGraphs.jl"/><meta property="twitter:title" content="Home · PlantGraphs.jl"/><meta name="description" content="Documentation for PlantGraphs.jl."/><meta property="og:description" content="Documentation for PlantGraphs.jl."/><meta property="twitter:description" content="Documentation for PlantGraphs.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PlantGraphs.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Graph-DSL"><span>Graph DSL</span></a></li><li><a class="tocitem" href="#Applying-rules-and-queries"><span>Applying rules and queries</span></a></li><li><a class="tocitem" href="#Extracting-information"><span>Extracting information</span></a></li><li><a class="tocitem" href="#Node-relations"><span>Node relations</span></a></li><li class="toplevel"><a class="tocitem" href="#Traversal-algorithms"><span>Traversal algorithms</span></a></li><li><a class="tocitem" href="#Graph-visualization"><span>Graph visualization</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/master/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Graphs"><a class="docs-heading-anchor" href="#Graphs">Graphs</a><a id="Graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Graphs" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Graph" href="#PlantGraphs.Graph"><code>PlantGraphs.Graph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Graph(;axiom, rules = nothing, data = nothing)</code></pre><p>Create a dynamic graph from an axiom, one or more rules and, optionally, graph-level variables.</p><p><strong>Arguments</strong></p><ul><li><code>axiom</code>: A single object inheriting from <code>Node</code> or a subgraph generated  with</li></ul><p>the graph construction DSL. It should represent the initial state of the dynamic graph.</p><p><strong>Keywords</strong></p><ul><li><code>rules</code>:  A single <code>Rule</code> object or a tuple of <code>Rule</code> objects (optional). It</li></ul><p>should include all graph-rewriting rules of the graph.</p><ul><li><code>data</code>: A single object of any user-defined type (optional). This will be the</li></ul><p>graph-level variable accessible from any rule or query applied to the graph.</p><ul><li><code>FT</code>: Floating-point precision to be used when generating the 3D geometry</li></ul><p>associated to a graph.</p><p><strong>Details</strong></p><p>All arguments are assigned by keyword. The axiom and rules are deep-copied when creating the graph but the graph-level variables (if a copy is needed due to mutability, the user needs to care of that).</p><p><strong>Returns</strong></p><p>An object of type <code>Graph</code> representing a dynamic graph. Printing this object results in a human-readable description of the type of data stored in the graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A0 &lt;: Node end
           struct B0 &lt;: Node end
           axiom = A0() + B0()
           no_rules_graph = Graph(axiom = axiom)
           rule = Rule(A0, rhs = x -&gt; A0() + B0())
           rules_graph = Graph(axiom = axiom, rules = rule)
       end
Dynamic graph with 2 nodes of types A0,B0 and 1 rewriting rules.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Graph.jl#L7-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Rule" href="#PlantGraphs.Rule"><code>PlantGraphs.Rule</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Rule(nodetype; lhs = x -&gt; true, rhs = x -&gt; nothing, captures = false)</code></pre><p>Create a replacement rule for nodes of type <code>nodetype</code>.</p><p><strong>Arguments</strong></p><ul><li><code>nodetype</code>: Type of node to be matched.</li></ul><p><strong>Keywords</strong></p><ul><li><code>lhs</code>: Function or function-like object that takes a <code>Context</code> object and</li></ul><p>returns whether the node should be replaced or not (with <code>true</code> or <code>false</code>).</p><ul><li><code>rhs</code>: Function or function-like object that takes one or more <code>Context</code></li></ul><p>objects and returns a replacement graph or <code>nothing</code>. If it takes several inputs, the first one will correspond to the node being replaced.</p><ul><li><code>captures</code>: Either <code>false</code> or <code>true</code> to indicate whether the left-hand side</li></ul><p>of the rule is capturing nodes in the context of the replacement node to be used for the construction of the replace graph.</p><p><strong>Details</strong></p><p>See VPL documentation for details on rule-based graph rewriting.</p><p><strong>Return</strong></p><p>An object of type <code>Rule</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A &lt;: Node end
           struct B &lt;: Node end
           axiom = A() + B()
           rule = Rule(A, rhs = x -&gt; A() + B())
           rules_graph = Graph(axiom = axiom, rules = rule)
           rewrite!(rules_graph)
           end
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Rule.jl#L7-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Query" href="#PlantGraphs.Query"><code>PlantGraphs.Query</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Query(N::DataType; condition = x -&gt; true)</code></pre><p>Create a query that matches nodes of type <code>nodetype</code> and a <code>condition</code>.</p><p><strong>Arguments</strong></p><ul><li><code>N::DataType</code>: Type of node to be matched.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: Function or function-like object that checks if a node should be</li></ul><p>selected.</p><p><strong>Details</strong></p><p>If the <code>nodetype</code> should refer to a concrete type and match one of the types stored inside the graph. Abstract types or types that are not contained in the graph are allowed but the query will never return anything.</p><p>The <code>condition</code> must be a function or function-like object that takes a <code>Context</code> as input and returns <code>true</code> or <code>false</code>. The default <code>condition</code> always return <code>true</code> such that the query will</p><p><strong>Returns</strong></p><p>It returns an object of type <code>Query</code>. Use <code>apply()</code> to execute the query on a dynamic graph.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end


julia&gt; struct B &lt;: Node end


julia&gt; axiom = A() + B();

julia&gt; g = Graph(axiom = axiom)
Dynamic graph with 2 nodes of types A,B and 0 rewriting rules.

julia&gt; query = Query(A)
Query object for nodes of type A

julia&gt; apply(g, query)
1-element Vector{A}:
 A()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Query.jl#L7-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Node" href="#PlantGraphs.Node"><code>PlantGraphs.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Node</code></pre><p>Abstract type from which every node in a graph should inherit. This allows using the graph construction DSL.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
         struct bar &lt;: Node
           x::Int
         end
         b1 = bar(1)
         b2 = bar(2)
         b1 + b2
       end;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Types.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.Context" href="#PlantGraphs.Context"><code>PlantGraphs.Context</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Context</code></pre><p>Data structure than links a node to the rest of the graph.</p><p><strong>Fields</strong></p><ul><li><code>graph</code>: Dynamic graph that contains the node.</li><li><code>node</code>: Node inside the graph.</li></ul><p><strong>Details</strong></p><p>A <code>Context</code> object wraps references to a node and its associated graph. The purpose of this structure is to be able to test relationships among nodes within a graph (from with a query or rule), as well as access the data stored in a node (with <code>data()</code>) or the graph (with <code>graph_data()</code>).</p><p>Users do not build <code>Context</code> objects directly but they are provided by VPL as inputs to the user-defined functions inside rules and queries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Types.jl#L89-L106">source</a></section></article><h2 id="Graph-DSL"><a class="docs-heading-anchor" href="#Graph-DSL">Graph DSL</a><a id="Graph-DSL-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-DSL" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{Node, Node}" href="#Base.:+-Tuple{Node, Node}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(n1::Node, n2::Node)</code></pre><p>Creates a graph with two nodes where <code>n1</code> is the root and <code>n2</code> is the insertion point.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(1) + B1(1)
           import CairoMakie # or GLMakie, WGLMakie, etc.
           draw(axiom)
       end
Figure()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/GraphConstruction.jl#L52-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{PlantGraphs.StaticGraph, Node}" href="#Base.:+-Tuple{PlantGraphs.StaticGraph, Node}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(g::StaticGraph, n::Node)</code></pre><p>Creates a graph as the result of appending the node <code>n</code> to the insertion point of graph <code>g</code>.</p><p><strong>Examples</strong></p><pre><code class="language-juliav hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(1) + B1(1)
           axiom = axiom + A1(2)
           import CairoMakie # or GLMakie, WGLMakie, etc.
           draw(axiom)
       end
Figure()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/GraphConstruction.jl#L77-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{Node, PlantGraphs.StaticGraph}" href="#Base.:+-Tuple{Node, PlantGraphs.StaticGraph}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(n::Node, g::StaticGraph)</code></pre><p>Creates a graph as the result of appending the static graph <code>g</code> to the node <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(1) + B1(1)
           axiom = A1(2) + axiom
           import CairoMakie # or GLMakie, WGLMakie, etc.
           draw(axiom)
       end
Figure()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/GraphConstruction.jl#L97-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.StaticGraph}" href="#Base.:+-Tuple{PlantGraphs.StaticGraph, PlantGraphs.StaticGraph}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(g1::StaticGraph, g2::StaticGraph)</code></pre><p>Creates a graph as the result of appending <code>g2</code> to the insertion point of <code>g1</code>. The insertion point of the final graph corresponds to the insertion point of <code>g2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom1 = A1(1) + B1(1)
           axiom2 = A1(2) + B1(2)
           axiom = axiom1 + axiom2
           import CairoMakie # or GLMakie, WGLMakie, etc.
           draw(axiom)
       end
Figure()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/GraphConstruction.jl#L118-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:+-Tuple{Node, Tuple}" href="#Base.:+-Tuple{Node, Tuple}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">+(g::StaticGraph, T::Tuple)
+(n::Node, T::Tuple)</code></pre><p>Creates a graph as the result of appending a tuple of graphs/nodes <code>T</code> to the insertion point of the graph <code>g</code> or node <code>n</code>. Each graph/node in <code>L</code> becomes a branch.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(1) + (B1(1) + A1(3), B1(4))
           import CairoMakie # or GLMakie, WGLMakie, etc.
           draw(axiom)
       end
Figure()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/GraphConstruction.jl#L155-L174">source</a></section></article><h2 id="Applying-rules-and-queries"><a class="docs-heading-anchor" href="#Applying-rules-and-queries">Applying rules and queries</a><a id="Applying-rules-and-queries-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-rules-and-queries" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.apply-Tuple{Graph, Query}" href="#PlantGraphs.apply-Tuple{Graph, Query}"><code>PlantGraphs.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(g::Graph, query::Query)</code></pre><p>Return an array with all the nodes in the graph that match the query supplied by the user.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end


julia&gt; struct B &lt;: Node end


julia&gt; axiom = A() + B();

julia&gt; g = Graph(axiom = axiom)
Dynamic graph with 2 nodes of types A,B and 0 rewriting rules.

julia&gt; query = Query(A)
Query object for nodes of type A

julia&gt; apply(g, query)
1-element Vector{A}:
 A()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Query.jl#L74-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.rewrite!-Tuple{Graph}" href="#PlantGraphs.rewrite!-Tuple{Graph}"><code>PlantGraphs.rewrite!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rewrite!(g::Graph)</code></pre><p>Apply the graph-rewriting rules stored in the graph.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph to be rewritten. It will be modified in-place.</li></ul><p><strong>Details</strong></p><p>This function will match the left-hand sides of all the rules in a graph. If any node is matched by more than one rule this will result in an error. The rules are then applied in order to replaced the matched nodes with the result of executing the right hand side of the rules. The rules are applied in the order in which they are stored in the graph but the order in which the nodes are processed is not defined. Since graph rewriting is semantically a parallel process, the rules should not be rely on any particular order for their functioning.</p><p><strong>Returns</strong></p><p>This function returns <code>nothing</code>, but the graph passed as input will be modified by the execution of the rules.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A &lt;: Node end
           struct B &lt;: Node end
           axiom = A() + B()
           rule = Rule(A, rhs = x -&gt; A() + B())
           g = Graph(axiom = axiom, rules = rule)
           rewrite!(g)
       end
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Rule.jl#L164-L198">source</a></section></article><h2 id="Extracting-information"><a class="docs-heading-anchor" href="#Extracting-information">Extracting information</a><a id="Extracting-information-1"></a><a class="docs-heading-anchor-permalink" href="#Extracting-information" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.data-Tuple{Graph}" href="#PlantGraphs.data-Tuple{Graph}"><code>PlantGraphs.data</code></a> — <span class="docstring-category">Method</span></header><section><div><p>data(g::Graph)</p><p>Returns the graph-level variables.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end


julia&gt; axiom = A()
A()

julia&gt; g = Graph(axiom = axiom, data = 2)
Dynamic graph with 1 nodes of types A and 0 rewriting rules.
Dynamic graph variables stored in struct of type Int64

julia&gt; data(g)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Graph.jl#L91-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.rules-Tuple{Graph}" href="#PlantGraphs.rules-Tuple{Graph}"><code>PlantGraphs.rules</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rules(g::Graph)</code></pre><p>Returns a tuple with all the graph-rewriting rules stored in a dynamic graph</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; struct A &lt;: Node end


julia&gt; struct B &lt;: Node end


julia&gt; axiom = A() + B();

julia&gt; rule = Rule(A, rhs = x -&gt; A() + B())
Rule replacing nodes of type A without context capturing.

julia&gt; rules_graph = Graph(axiom = axiom, rules = rule)
Dynamic graph with 2 nodes of types A,B and 1 rewriting rules.

julia&gt; rules(rules_graph)
(Rule replacing nodes of type A without context capturing.
,)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Graph.jl#L63-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.data-Tuple{PlantGraphs.Context}" href="#PlantGraphs.data-Tuple{PlantGraphs.Context}"><code>PlantGraphs.data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">data(c::Context)</code></pre><p>Returns the data stored in a node. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.graph_data-Tuple{PlantGraphs.Context}" href="#PlantGraphs.graph_data-Tuple{PlantGraphs.Context}"><code>PlantGraphs.graph_data</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">graph_data(c::Context)</code></pre><p>Returns the graph-level variables. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L20-L24">source</a></section></article><h2 id="Node-relations"><a class="docs-heading-anchor" href="#Node-relations">Node relations</a><a id="Node-relations-1"></a><a class="docs-heading-anchor-permalink" href="#Node-relations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.has_parent-Tuple{PlantGraphs.Context}" href="#PlantGraphs.has_parent-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_parent(c::Context)</code></pre><p>Check if a node has a parent and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractTrees.isroot-Tuple{PlantGraphs.Context}" href="#AbstractTrees.isroot-Tuple{PlantGraphs.Context}"><code>AbstractTrees.isroot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isroot(c::Context)</code></pre><p>Check if a node is the root of the graph (i.e., has no parent) and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.has_ancestor-Tuple{PlantGraphs.Context}" href="#PlantGraphs.has_ancestor-Tuple{PlantGraphs.Context}"><code>PlantGraphs.has_ancestor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">has_ancestor(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Check if a node has an ancestor that matches the condition. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input</li></ul><p>and returns <code>true</code> or <code>false</code>.</p><ul><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when</li></ul><p>traversing the graph.</p><p><strong>Details</strong></p><p>This function traverses the graph from the node associated to <code>c</code> towards the root of the graph until a node is found for which <code>condition</code> returns <code>true</code>. If no node meets the condition, then it will return <code>false</code>. The defaults values for this function are such that the algorithm always returns <code>true</code> after one step (unless it is applied to the root node) in which case it is equivalent to calling <code>has_parent</code> on the node.</p><p>The number of levels that the algorithm is allowed to traverse is capped by <code>max_level</code> (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).</p><p>The function <code>condition</code> should take an object of type <code>Context</code> as input and return <code>true</code> or <code>false</code>.</p><p><strong>Returns</strong></p><p>Return a tuple with two values a <code>Bool</code> and an <code>Int</code>, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(2) + (B1(1) + A1(3), B1(4))
           g = Graph(axiom = axiom)
               function qfun(n)
               has_ancestor(n, condition = x -&gt; data(x).val == 1)[1]
           end
           Q1 = Query(A1, condition = qfun)
           R1 = apply(g, Q1)
               Q2 = Query(B1, condition = qfun)
           R2 = apply(g, Q2)
           (R1,R2)
       end
(A1[A1(3)], B1[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L50-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.parent-Tuple{PlantGraphs.Context}" href="#Base.parent-Tuple{PlantGraphs.Context}"><code>Base.parent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parent(c::Context; nsteps::Int)</code></pre><p>Returns the parent of a node that is <code>nsteps</code> away towards the root of the graph. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>nsteps</code>: Number of steps to traverse the graph towards the root node.</li></ul><p><strong>Details</strong></p><p>If <code>has_parent()</code> returns <code>false</code> for the same node or the algorithm has reached the root node but <code>nsteps</code> have not been reached, then <code>parent()</code> will return <code>missing</code>, otherwise it returns the <code>Context</code> associated to the matching node.</p><p><strong>Return</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(2) + (B1(1) + A1(3), B1(4))
           g = Graph(axiom = axiom)
               function qfun(n)
               np = parent(n, nsteps = 2)
               !ismissing(np) &amp;&amp; data(np).val == 2
           end
           Q1 = Query(A1, condition = qfun)
           R1 = apply(g, Q1)
           Q2 = Query(B1, condition = qfun)
           R2 = apply(g, Q2)
           (R1,R2)
       end
(A1[A1(3)], B1[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L188-L227">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.ancestor-Tuple{PlantGraphs.Context}" href="#PlantGraphs.ancestor-Tuple{PlantGraphs.Context}"><code>PlantGraphs.ancestor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ancestor(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Returns the first ancestor of a node that matches the <code>condition</code>. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input</li></ul><p>and returns <code>true</code> or <code>false</code>.</p><ul><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when</li></ul><p>traversing the graph.</p><p><strong>Details</strong></p><p>If <code>has_ancestor()</code> returns <code>false</code> for the same node and <code>condition</code>, <code>ancestor()</code> will return <code>missing</code>, otherwise it returns the <code>Context</code> associated to the matching node</p><p><strong>Returns</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(1) + (B1(1) + A1(3), B1(4))
           g = Graph(axiom = axiom)
               function qfun(n)
               na = ancestor(n, condition = x -&gt; (data(x).val == 1))
               if !ismissing(na)
                   data(na) isa B1
               else
                   false
               end
           end
           Q1 = Query(A1, condition = qfun)
           R1 = apply(g, Q1)
           Q2 = Query(B1, condition = qfun)
           R2 = apply(g, Q2)
           (R1,R2)
       end
(A1[A1(3)], B1[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L235-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.haschildren-Tuple{PlantGraphs.Context}" href="#PlantGraphs.haschildren-Tuple{PlantGraphs.Context}"><code>PlantGraphs.haschildren</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">haschildren(c::Context)</code></pre><p>Check if a node has at least one child and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L109-L114">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.isleaf-Tuple{PlantGraphs.Context}" href="#PlantGraphs.isleaf-Tuple{PlantGraphs.Context}"><code>PlantGraphs.isleaf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isleaf(c::Context)</code></pre><p>Check if a node is a leaf in the graph (i.e., has no children) and return <code>true</code> or <code>false</code>. Intended to be used within a rule or query.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L117-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.hasdescendant-Tuple{PlantGraphs.Context}" href="#PlantGraphs.hasdescendant-Tuple{PlantGraphs.Context}"><code>PlantGraphs.hasdescendant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hasdescendant(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Check if a node has a descendant that matches the optional condition. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input</li></ul><p>and returns <code>true</code> or <code>false</code>.</p><ul><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when</li></ul><p>traversing the graph.</p><p><strong>Details</strong></p><p>This function traverses the graph from the node associated to <code>c</code> towards the leaves of the graph until a node is found for which <code>condition</code> returns <code>true</code>. If no node meets the condition, then it will return <code>false</code>. The defaults values for this function are such that the algorithm always returns <code>true</code> after one step (unless it is applied to a leaf node) in which case it is equivalent to calling <code>haschildren</code> on the node.</p><p>The number of levels that the algorithm is allowed to traverse is capped by <code>max_level</code> (mostly to avoid excessive computation, though the user may want to specify a meaningful limit based on the topology of the graphs being used).</p><p>The function <code>condition</code> should take an object of type <code>Context</code> as input and return <code>true</code> or <code>false</code>.</p><p><strong>Returns</strong></p><p>Return a tuple with two values a <code>Bool</code> and an <code>Int</code>, the boolean indicating whether the node has an ancestor meeting the condition, the integer indicating the number of levels in the graph separating the node an its ancestor.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(2) + (B1(1) + A1(3), B1(4))
           g = Graph(axiom = axiom)
               function qfun(n)
               hasdescendant(n, condition = x -&gt; data(x).val == 1)[1]
           end
           Q1 = Query(A1, condition = qfun)
           R1 = apply(g, Q1)
           Q2 = Query(B1, condition = qfun)
           R2 = apply(g, Q2)
           (R1,R2)
       end
(A1[A1(2)], B1[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L125-L178">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractTrees.children-Tuple{PlantGraphs.Context}" href="#AbstractTrees.children-Tuple{PlantGraphs.Context}"><code>AbstractTrees.children</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">children(c::Context)</code></pre><p>Returns all the children of a node as <code>Context</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AbstractTrees.getdescendant-Tuple{PlantGraphs.Context}" href="#AbstractTrees.getdescendant-Tuple{PlantGraphs.Context}"><code>AbstractTrees.getdescendant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getdescendant(c::Context; condition = x -&gt; true, max_level::Int = typemax(Int))</code></pre><p>Returns the first descendant of a node that matches the <code>condition</code>. Intended to be used within a rule or query.</p><p><strong>Arguments</strong></p><ul><li><code>c::Context</code>: Context associated to a node in a dynamic graph.</li></ul><p><strong>Keywords</strong></p><ul><li><code>condition</code>: An user-defined function that takes a <code>Context</code> object as input</li></ul><p>and returns <code>true</code> or <code>false</code>.</p><ul><li><code>max_level::Int</code>: Maximum number of steps that the algorithm may take when</li></ul><p>traversing the graph.</p><p><strong>Details</strong></p><p>If <code>hasdescendant()</code> returns <code>false</code> for the same node and <code>condition</code>, <code>getdescendant()</code> will return <code>missing</code>, otherwise it returns the <code>Context</code> associated to the matching node.</p><p><strong>Return</strong></p><p>Return a <code>Context</code> object or <code>missing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(1) + (B1(1) + A1(3), B1(4))
           g = Graph(axiom = axiom)
               function qfun(n)
               na = getdescendant(n, condition = x -&gt; (data(x).val == 1))
               if !ismissing(na)
                   data(na) isa B1
               else
                   false
               end
           end
           Q1 = Query(A1, condition = qfun)
           R1 = apply(g, Q1)
           Q2 = Query(B1, condition = qfun)
           R2 = apply(g, Q2)
           (R1,R2)
       end
(A1[A1(1)], B1[])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Context.jl#L299-L345">source</a></section></article><h1 id="Traversal-algorithms"><a class="docs-heading-anchor" href="#Traversal-algorithms">Traversal algorithms</a><a id="Traversal-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Traversal-algorithms" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.traverse-Tuple{Graph}" href="#PlantGraphs.traverse-Tuple{Graph}"><code>PlantGraphs.traverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traverse(g::Graph; fun = () -&gt; nothing)</code></pre><p>Iterates over all the nodes in the graph and execute for the function <code>fun</code> on each node</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph object that will be traversed.</li></ul><p><strong>Keywords</strong></p><ul><li><code>fun</code>: A function or function-like object defined by the user that will be</li></ul><p>applied to each node.</p><p><strong>Details</strong></p><p>This traveral happens in the order in which the nodes are stored in the graph. This order is arbitrary and may vary across executions of the code (it does not correspond to the order in which nodes are created). For algorithms that require a particular traveral order of the graph, see <code>traversedfs</code> and <code>traversebfs</code>.</p><p>This function does not store any results generated by <code>fun</code>. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).</p><p>The function or function-like object provided by the user should take only one argument that corresponds to applying <code>data()</code> to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see <code>Query</code> and general VPL documentation).</p><p><strong>Returns</strong></p><p>This function returns nothing but <code>fun</code> may have side-effects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           struct Foo
               vals::Vector{Int}
           end
           function (f::Foo)(x)
                   push!(f.vals, x.val)
           end
           f = Foo(Int[])
               axiom = A1(2) + (B1(1) + A1(3), B1(4))
                   g = Graph(axiom = axiom)
           traverse(g, fun = f)
           f.vals
       end
4-element Vector{Int64}:
 2
 1
 3
 4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Algorithms.jl#L7-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.traversedfs-Tuple{Graph}" href="#PlantGraphs.traversedfs-Tuple{Graph}"><code>PlantGraphs.traversedfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traversedfs(g::Graph; fun = () -&gt; nothing, ID = root_id(g))</code></pre><p>Iterates over all the nodes in the graph (depth-first order, starting at a any node) and execute for the function <code>fun</code> on each node</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph object that will be traversed.</li></ul><p><strong>Keywords</strong></p><ul><li><code>fun</code>: A function or function-like object defined by the user that will be</li></ul><p>applied to each node.</p><ul><li><code>ID</code>: The ID of the node where the traveral should start. This argument is</li></ul><p>assigned by keyword and is, by default, the root of the graph.</p><p><strong>Details</strong></p><p>This traveral happens in a depth-first order. That is, all nodes in a branch of the graph are visited until reach a leaf node, then moving to the next branch. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us breadth-first order see <code>traversebfs</code>.</p><p>This function does not store any results generated by <code>fun</code>. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).</p><p>The function or function-like object provided by the user should take only one argument that corresponds to applying <code>data()</code> to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see <code>Query</code> and general VPL documentation).</p><p><strong>Returns</strong></p><p>This function returns nothing but <code>fun</code> may have side-effects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           struct Foo
               vals::Vector{Int}
           end
           function (f::Foo)(x)
                   push!(f.vals, x.val)
           end
           f = Foo(Int[])
           axiom = A1(2) + (B1(1) + A1(3), B1(4))
               g = Graph(axiom = axiom)
           traversedfs(g, fun = f)
           f.vals
       end
4-element Vector{Int64}:
 2
 4
 1
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Algorithms.jl#L81-L141">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.traversebfs-Tuple{Graph}" href="#PlantGraphs.traversebfs-Tuple{Graph}"><code>PlantGraphs.traversebfs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">traversebfs(g::Graph; fun = () -&gt; nothing, ID = root_id(g))</code></pre><p>Iterates over all the nodes in the graph (breadth-first order, starting at a any node) and execute for the function <code>fun</code> on each node</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph object that will be traversed.</li></ul><p><strong>Keywords</strong></p><ul><li><code>fun</code>: A function or function-like object defined by the user that will be</li></ul><p>applied to each node.</p><ul><li><code>ID</code>: The ID of the node where the traveral should start. This argument is, by default,</li></ul><p>the root of the graph.</p><p><strong>Details</strong></p><p>This traveral happens in a breadth-first order. That is, all nodes at a given depth of the the graph are visited first, then moving on to the next level. Hence, this algorithm should always generate the same result when applied to the same graph (assuming the user-defined function is not stochastic). For a version of this function that us depth-first order see <code>traversedfs</code>.</p><p>This function does not store any results generated by <code>fun</code>. Hence, if the user wants to keep track of such results, they should be stored indirectly (e.g., via a global variable or internally by creating a functor).</p><p>The function or function-like object provided by the user should take only one argument that corresponds to applying <code>data()</code> to each node in the graph. Several methods of such function may be defined for different types of nodes in the graph. Since the function will use the data stored in the nodes, relations among nodes may not be used as input. For algorithms where relations among nodes are important, the user should be using queries instead (see <code>Query</code> and general VPL documentation).</p><p><strong>Returns</strong></p><p>This function returns nothing but <code>fun</code> may have side-effects.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           struct Foo
               vals::Vector{Int}
           end
           function (f::Foo)(x)
               push!(f.vals, x.val)
           end
           f = Foo(Int[])
               axiom = A1(2) + (B1(1) + A1(3), B1(4))
                   g = Graph(axiom = axiom)
           traversebfs(g, fun = f)
           f.vals
       end
4-element Vector{Int64}:
 2
 1
 4
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Algorithms.jl#L163-L223">source</a></section></article><h2 id="Graph-visualization"><a class="docs-heading-anchor" href="#Graph-visualization">Graph visualization</a><a id="Graph-visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-visualization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.draw-Tuple{Graph}" href="#PlantGraphs.draw-Tuple{Graph}"><code>PlantGraphs.draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw(g::Graph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,
     node_size = 5)</code></pre><p>Visualize a graph as network diagram.</p><p><strong>Arguments</strong></p><ul><li><code>g::Graph</code>: The graph to be visualized.</li></ul><p><strong>Keywords</strong></p><ul><li><code>resolution = (1920, 1080)</code>: The resolution of the image to be rendered, in</li></ul><p>pixels (online relevant for native and web backends). Default resolution is HD.</p><ul><li><code>nlabels_textsize = 15</code>: Customize the size of the labels in the diagram.</li><li><code>arrow_size = 15</code>: Customize the size of the arrows representing edges in the</li></ul><p>diagram.</p><ul><li><code>node_size = 5</code>: Customize the size of the nodes in the diagram.</li></ul><p><strong>Details</strong></p><p>By default, nodes are labelled with the type of data stored and their unique ID. See function <code>node_label()</code> to customize the label for different types of data.</p><p>See <code>save</code> from FileIO to export the network diagram as a raster or vector image (depending on the backend). The function <code>calculate_resolution()</code> can be useful to ensure a particular dpi of the exported image (assuming some physical size).</p><p>The graphics backend will interact with the environment where the Julia code is being executed (i.e., terminal, IDE such as VS Code, interactive notebook such as Jupyter or Pluto). These interactions are all controlled by the graphics package Makie that VPL relies on. Some details on the expected behavior specific to <code>draw()</code> can be found in the general VPL documentation.</p><p><strong>Returns</strong></p><p>This function returns a Makie <code>Figure</code> object, while producing the visualization as a side effect.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; let
           struct A1 &lt;: Node val::Int end
           struct B1 &lt;: Node val::Int end
           axiom = A1(1) + (B1(1) + A1(3), B1(4))
           g = Graph(axiom = axiom)
           import CairoMakie # or GLMakie, WGLMakie, etc.
           draw(g)
       end
Figure()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Draw.jl#L96-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.draw-Tuple{PlantGraphs.StaticGraph}" href="#PlantGraphs.draw-Tuple{PlantGraphs.StaticGraph}"><code>PlantGraphs.draw</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">draw(g::StaticGraph; resolution = (1920, 1080), nlabels_textsize = 15, arrow_size = 15,
     node_size = 5)</code></pre><p>Equivalent to the method <code>draw(g::Graph; kwargs...)</code> but  to visualize static graphs (e.g., the axiom of a graph).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Draw.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.node_label-Tuple{Node, Any}" href="#PlantGraphs.node_label-Tuple{Node, Any}"><code>PlantGraphs.node_label</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">node_label(n::Node, id)</code></pre><p>Function to construct a label for a node to be used by <code>draw()</code> when visualizing. The user can specialize this method for user-defined data types to customize the labels. By default, the type of data stored in the node and the unique ID of the node are used as labels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Draw.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PlantGraphs.calculate_resolution-Tuple{}" href="#PlantGraphs.calculate_resolution-Tuple{}"><code>PlantGraphs.calculate_resolution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculate_resolution(;width = 1024/300*2.54, height = 768/300*2.54,
                      format = &quot;raster&quot;, dpi = 300)</code></pre><p>Calculate the resolution required to achieve a specific <code>width</code> and <code>height</code> (in cm) of the exported image, with a particular <code>dpi</code> (for raster formats).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/VirtualPlantLab/PlantGraphs.jl/blob/839f925bf4907ea34f61a08c900617314d7de1bf/src/Draw.jl#L152-L158">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.0 on <span class="colophon-date" title="Monday 18 September 2023 07:38">Monday 18 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
